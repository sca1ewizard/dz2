#define _CRT_SECURE_NO_WARNINGS
#define DEBUG 0
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#pragma warning(disable : 4996)

int main()
{	
	system("chcp 1251");        // добавляем поддержку русской раскладки
	system("cls");				// очищаем консоль
	char current;				// текущий введенный символ
	int k = 1;					// счётчик для выделения памяти	
	int i, j, n, length = 0;	// n - количество узлов, length - количество рёбер
	int full;                   // определяет единицы в получившейся матрице для записи в файл 
	FILE* file;					// указатель на файл
	int sum = 1;

//--------------------------------------------------------------//
//				  Ввод динамической матрицы						//
//--------------------------------------------------------------//
	printf("Введите количество узлов: ");	
	scanf_s("%d", &n);			// количество узлов
	int* flag = (int*)malloc(n * sizeof(int));		// выделение памяти под массив флагов для определения связности
	int** a = (int**)malloc(n * sizeof(int*));		// выделение памяти под массив строк
	for (int arr = 0; arr < n; arr++)				// выделяем по одной ячейке помяти размером int в каждой строке
	{
		a[arr] = (int*)malloc(sizeof(int));	
	}
	current = getchar();									// переход на новую строку после ввода количества узлов
	for (i = 0; i < n; i++)
	{
		printf("%d  : ", i);
		current = getchar();								// берём первый символ
		for (j = 0; current != '\n'; j++)					// читаем с клавиатуры до конца строки
		{
			if ((current == '1') || (current == '0'))		// если 0 или 1
			{
				a[i] = (int*)realloc(a[i], sizeof(int) * k);// довыделяем память на один больше (в начале int k = 1)
				(a[i])[k - 1] = (int)current - '0';			// записываем значение в ячёку массива
				++k;										//инк. счетчик для веделения памяти
			}
			current = getchar();	// получаем новое значение	
		}
		current = '\0';				// для перехода на новую строку возвращаем переменные к исх. виду
		length = k - 1;				// length - длина строк
		k = 1;						// присваиваем int к начальное значение
	}
	printf("\n\n"); 
//--------------------------------------------------------------//
//					   Вывод  в консоль						    //
//--------------------------------------------------------------//

	printf("\n\n   ");
	for (j = 1; j <= length; j++)
	{
		printf("%3i", j);
	}
	printf("\n");
	for (j = 1; j <= ((3 * length) + 7); j++)
	{
		printf("-");
	}
	printf("\n");

	for (i = 0; i < n; i++)
	{
		printf("%i| ",(i+1));
		for (j = 0; j < length; j++)
		{
			printf("%3d", a[i][j]);
		}
		printf("\n");
	}
//--------------------------------------------------------------//
//					Проверка на связность						//
//--------------------------------------------------------------//

	flag[0] = 1;
	for (i = 1; i < n; i++)
		flag[i] = 0;
	for (i = 0; i < n; i++)
	{
		//printf("сейчас обрабатывается строка %d \n", i);
		if (flag[i] == 1)
		{
			//printf("строка %d имеет флаг \n", i);
			for (j = 0; j < n; j++)
			{
				if (flag[j] != 1)
				{
					//printf(" основная строка %d сравнивается со строкой %d \n", i, j);
					for (int m = 0; m < length; m++)
					{
						if ((a[i][m] == 1) && (a[j][m] == 1))
						{
							flag[j] = 1;
							sum++;
							//printf("сейчас сумма %d \n", sum);
							break;
						}
					}
				}
			}
		}
	}
	if (sum == n)
		printf("Граф связан\n");
	else printf("Граф не связан");


//--------------------------------------------------------------//
//					  Работа с dot файлом						//
//--------------------------------------------------------------//
	if ((file = fopen("Dot_file.txt", "w")) == NULL) {		// открыли файл Dot_file.txt для записи
		printf("Cannot open file.\n");						// если ошибка, то печатаем ошибку
		exit(1);											// завершаем программу
	}
	fprintf(file,"graph G{\n");				// заполняем файл на языке dot


	int t = -1;							    // индекс первой встретившийся единицы
	full = 0;								// индекс количества единиц
	for (j = 0; j < length; j++)			// цикл по столбцам
	{
		for (i = 0; i < n; i++)				// цикл по строкам
		{
			if ((a[i][j] == 1) && (full > 2))                         // если в одном столбце две 1, то печатаем ошибку, т.к. это
																	  //	противоречит определению матрицы инцидентности
			{
				printf("Нельзя вводить больше 2 единицы в столбце");
				exit(-1);
			}
			else
			{
				if ((a[i][j] == 1) && (full == 0))   // изначально full = 0;
				{
					fprintf(file, "%d", (i + 1));	 // если нашли первыую единицу в столбце, то записываем в файл
					fprintf(file, " -- ");
					full++;							 // инк. full для поиска второй единицы
					t = i;							 // индекс первой единицы равен i
				}
				else
				{
					if ((a[i][j] == 1) && (full == 1))   // если нашли еще единицу и уже была единица (full = 1)
					{
						fprintf(file, "%d", (i + 1));	 // печатаем в соответствии с форматом
						fprintf(file, " [label=%d];\n", (j + 1));
						full++;
					}
				}
			}
		}
		if (full = 1)						// если встретилась только одна единица в столбце то значит вершина замкнута сама на себя
		{
			fprintf(file, "%d", (t + 1));   // печатаем её же
			fprintf(file, ";\n");
		}
		full = 0;			// обнуляем счётчики для анализа всл. столбца
		t = -1;			
	}
	fprintf(file,"}");		
	fclose(file);		// закрываем файл
	system("dot C:\\Users\\Professional\\Desktop\\Projects\\dz2\\Dot_file.txt -Tbmp -o Dot_file.bmp");	// вызываем dot и передаем ему записанный 
	                                                                                                    // файл Dot_file.txt и полученный граф сохраняем в Dot_file.bmp 

	system("rundll32  \"%ProgramFiles%\\Windows Photo Viewer\\PhotoViewer.dll\", ImageView_Fullscreen C:\\Users\\Professional\\Desktop\\Projects\\dz2\\Dot_file.bmp");
																				// запускаем встроенный просмотр фото в винде

//--------------------------------------------------------------//
//                     Очистка памяти                           //
//--------------------------------------------------------------//
	for (i = 0; i < n; i++) // проходим по массиву строк и очищаем его
	{
		free(a[i]); 
	}
	free(a);				// очищаем весь двумерный массив
	getchar();
	return 0;
}