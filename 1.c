#define _CRT_SECURE_NO_WARNINGS
#define DEBUG 0
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#pragma warning(disable : 4996)

int main()
{	
	system("chcp 1251");        // добавляем поддержку русской раскладки
	system("cls");		    // очищаем консоль
	char current;	            // текущий введенный символ
	int k = 1;		    // счётчик для выделения памяти	
	int i, j, n, length = 0;    // n - количество узлов, length - количество рёбер
	int full;                   // определяет единицы в получившейся матрице для записи в файл 
	FILE* file;		    // указатель на файл
	int sum = 1;

//--------------------------------------------------------------//
//	       Ввод динамической матрицы			//
//--------------------------------------------------------------//
	printf("Введите количество узлов: ");	
	scanf_s("%d", &n);			  	// количество узлов
	int* flag = (int*)malloc(n * sizeof(int));	// выделение памяти под массив флагов для определения связности
	int** a = (int**)malloc(n * sizeof(int*));	// выделение памяти под массив строк
	for (int arr = 0; arr < n; arr++)		// выделяем по одной ячейке помяти размером int в каждой строке
	{
		a[arr] = (int*)malloc(sizeof(int));	
	}
	current = getchar();				// переход на новую строку после ввода количества узлов
	for (i = 0; i < n; i++)
	{
		printf("%d  : ", i);
		current = getchar();			// берём первый символ
		for (j = 0; current != '\n'; j++)	// читаем с клавиатуры до конца строки
		{
			if ((current == '1') || (current == '0'))	 	// если 0 или 1
			{
				a[i] = (int*)realloc(a[i], sizeof(int) * k);	// довыделяем память на один больше (в начале int k = 1)
				(a[i])[k - 1] = (int)current - '0';		// записываем значение в ячёку массива
				++k;						//инк. счетчик для веделения памяти
			}
			current = getchar();		// получаем новое значение	
		}
		current = '\0';				// для перехода на новую строку возвращаем переменные к исх. виду
		length = k - 1;				// length - длина строк
		k = 1;					// присваиваем int к начальное значение
	}
	printf("\n\n"); 
//--------------------------------------------------------------//
//	               Вывод  в консоль				//
//--------------------------------------------------------------//

	printf("\n\n   ");
	for (j = 1; j <= length; j++)
	{
		printf("%3i", j);
	}
	printf("\n");
	for (j = 1; j <= ((3 * length) + 7); j++)
	{
		printf("-");
	}
	printf("\n");

	for (i = 0; i < n; i++)
	{
		printf("%i| ",(i+1));
		for (j = 0; j < length; j++)
		{
			printf("%3d", a[i][j]);
		}
		printf("\n");
	}
//--------------------------------------------------------------//
//		Проверка на связность				//
//--------------------------------------------------------------//

	flag[0] = 1;
	for (i = 1; i < n; i++)
		flag[i] = 0;
	for (i = 0; i < n; i++)
	{
		//printf("сейчас обрабатывается строка %d \n", i);
		if (flag[i] == 1)
		{
			//printf("строка %d имеет флаг \n", i);
			for (j = 0; j < n; j++)
			{
				if (flag[j] != 1)
				{
					//printf(" основная строка %d сравнивается со строкой %d \n", i, j);
					for (int m = 0; m < length; m++)
					{
						if ((a[i][m] == 1) && (a[j][m] == 1))
						{
							flag[j] = 1;
							sum++;
							//printf("сейчас сумма %d \n", sum);
							break;
						}
					}
				}
			}
		}
	}
	if (sum == n)
		printf("Граф связан\n");
	else printf("Граф не связан");


//--------------------------------------------------------------//
//		Работа с dot файлом				//
//--------------------------------------------------------------//
	if ((file = fopen("Dot_file.txt", "w")) == NULL) {	// открыли файл Dot_file.txt для записи
		printf("Cannot open file.\n");			// если ошибка, то печатаем ошибку
		exit(1);					// завершаем программу
	}
	fprintf(file,"graph G{\n");				// заполняем файл на языке dot


	int t = -1;					// индекс первой встретившийся единицы
	full = 0;					// индекс количества единиц
	for (i = 0; i < n; i++)
	{
		fprintf(file, "%d;\n", (i + 1));
	}
	for (j = 0; j < length; j++)			// цикл по столбцам
	{
		for (i = 0; i < n; i++)			// цикл по строкам
		{
			if ((a[i][j] == 1) && (full > 2))        // если в одном столбце две 1, то печатаем ошибку, т.к. это
								 //	противоречит определению матрицы инцидентности
			{
				printf("Нельзя вводить больше 2 единицы в столбце");
				exit(-1);
			}
			else
			{
				if ((a[i][j] == 1) && (full == 0))   // изначально full = 0;
				{
					fprintf(file, "%d", (i + 1));	 // если нашли первыую единицу в столбце, то записываем в файл
					fprintf(file, " -- ");
					full++;				// инк. full для поиска второй единицы
					t = i;				// индекс первой единицы равен i
				}
				else
				{
					if ((a[i][j] == 1) && (full == 1))       // если нашли еще единицу и уже была единица (full = 1)
					{
						fprintf(file, "%d", (i + 1));	 // печатаем в соответствии с форматом
						fprintf(file, " [label=%d];\n", (j + 1));
						full++;
					}
				}
			}
		}
		if (t > -1)
		{
			if (full = 1)				// если встретилась только одна единица в столбце то значит вершина замкнута сама на себя
			{
				fprintf(file, "%d", (t + 1));   // печатаем её же
				fprintf(file, ";\n");
			}
		}
		full = 0;		// обнуляем счётчики для анализа всл. столбца
		t = -1;			
	}
	fprintf(file,"}");		
	fclose(file);		// закрываем файл
	system("dot C:\\Users\\Professional\\Desktop\\Projects\\dz2\\Dot_file.txt -Tbmp -o Dot_file.bmp");	// вызываем dot и передаем ему записанный 
	                                                                                                    // файл Dot_file.txt и полученный граф сохраняем в Dot_file.bmp 

	system("rundll32  \"%ProgramFiles%\\Windows Photo Viewer\\PhotoViewer.dll\", ImageView_Fullscreen C:\\Users\\Professional\\Desktop\\Projects\\dz2\\Dot_file.bmp");
																				// запускаем встроенный просмотр фото в винде

//--------------------------------------------------------------//
//                     Очистка памяти                           //
//--------------------------------------------------------------//
	for (i = 0; i < n; i++)                 // проходим по массиву строк и очищаем его
	{
		free(a[i]); 
	}
	free(a);				// очищаем весь двумерный массив
	getchar();
	return 0;
}
